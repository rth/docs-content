---
meta:
  title: How to deploy both x86 and ARM images in Kubernetes
  description: This page explains how to deploy both x86 and ARM images in Kubernetes
content:
  h1: How to deploy both x86 and ARM images in Kubernetes
  paragraph: This page explains how to deploy both x86 and ARM images in Kubernetes
tags: kubernetes kapsule arm x86
dates:
  validation: 2024-02-29
  posted: 2024-02-29
categories:
  - kubernetes
---

In a multi-architecture computing environment, where both x86 and ARM architectures are used, deploying applications in a Kubernetes cluster can present challenges.
However, Kubernetes provides several mechanisms to manage architectural diversity effectively. Two of the most common approaches are using multi-arch images and architecture-specific deployments.

## What is ARM architecture, and why is it different from x86?

 - ARM architecture is commonly used in devices like Raspberry Pi, IoT devices, and recent [Cost-Optimized Instances based on ARM](https://www.scaleway.com/en/cost-optimized-instances-based-on-arm/).
 - Kubernetes clusters may consist of nodes with different architectures, including x86 and ARM.
 - Deploying applications across these diverse architectures requires special consideration.

For a detailed comparison between ARM and x86 architectures, refer to our dedicated documentation [Understanding the differences between ARM and x86 Instances](/compute/instances/reference-content/understanding-differences-x86-arm/).

## Using multi-arch images

The most common approach to using ARM and x86 architecture Instances in a Kubernetes cluster is multi-arch images.
These images contain binaries for multiple architectures, allowing Kubernetes to pull the appropriate binaries for each node.

### How to deploy multi-arch images

1. Build multi-arch images. Docker supports multi-arch builds using `buildx`.
2. Push the built images to a container registry accessible by your Kubernetes cluster. For example, you can use the [Scaleway Container Registry](/containers/container-registry/quickstart/).
3. Specify node selectors and affinity. Use [node selectors](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector) and [affinity rules](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity) to ensure pods are scheduled on nodes with compatible architectures.
4. Use taints to mark nodes with specific architectures and tolerations to allow pods to run on those nodes. Refer to the [official Kubernetes documentation](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/) for more information regarding taints and tolerations.

<Message type="tip">
  Using multi-arch images you benefit from a
    - simplified deployment process.
    - scalable solution for managing multi-architecture clusters.
</Message>

## Using architecture-specific deployments

In cases where multi-arch images are not possible, architecture-specific deployments can be an alternative.

Here are the steps for architecture-specific deployments:

1. Start by determining the architecture of each node in the Kubernetes cluster.
2. Build architecture-specific images by creating separate images for each architecture (x86 and ARM).
3. Assign [labels](https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetes-io-arch) to images with the corresponding architecture name.
4. Deploy with architecture-specific manifests for each architecture.

<Message type="note">
  Keep in mind that,
  - there is an increased management overhead due to maintaining separate images and manifests.
  - this approach is mostly suitable for scenarios where multi-arch images are not suitable.
</Message>

<Navigation title="See also">
  <PreviousButton to="/containers/kubernetes/how-to/use-scratch-storage-h100/">How to use scratch storage with H100 GPUs and Kubernetes Kapsule</PreviousButton>
  <NextButton to="/containers/kubernetes/how-to/enable-disable-ssh/">How to enable or disable SSH ports on Kubernetes Kapsule cluster nodes</NextButton>
</Navigation>